---
title: NEBA User Guide
layout: fullwidth
description: A comprehensive guide to using the NEBA features
twitterAuthor: deploynix
---

<div class="section-title">
    <h1 class="title">NEBA User guide:<span> developing with NEBA</span></h1>
</div>

<div class="one">
<h2>Table of contents</h2>
<ul class="colored-counter-list">
    <li><a href="#installing">Installing NEBA</a></li>
    <li>
        <a href="#resourcemodels">Writing @ResourceModels</a>
        <ul class="colored-counter-list">
            <li><a href="#resourceModelDefinition">Resources, resource types and resource models</a></li>
            <li><a href="#nebaDefineObjects">The neba:defineObjects tag</a></li>
            <li><a href="#resourceToModelMapping">Mapping properties and resources to models</a></li>
            <li><a href="#resourceAnnotations">Annotations for advanced resource to model mapping</a></li>
            <li><a href="#modelInitialization">Performing additional initializations</a></li>
        </ul>
    </li>
    <li><a href="#beanscopes">Support for web-specific bean scopes</a></li>
    <li><a href="#usingvelocity">Rendering beyond resources with Velocity</a></li>
    <li><a href="#springmvc">Using Spring MVC in Sling</a></li>
    <li><a href="#extending">Extending NEBA</a></li>
</ul>
</div>

<div class="divider-border"></div>

<div class="one">
    <h2 id="installing">Installing and integrating NEBA</h2>
    <p>The fastest way to start with NEBA is to follow the <a href="quickstart.html">Quick start guide</a>.</p>
</div>

<div class="divider-border"></div>

<div class="one">
<h2 id="resourcemodels">Writing @ResourceModels</h2>

<h3 id="resourceModelDefinition">Resources, resource types and resource models</h3>

<p>Let's assume we need a simple JAVA model for the geometrixx site, specifically, for the  &quot;carousel&quot; component.
    The carousel has the resource type &quot;foundation/components/carousel&quot;:</p>
<p><img src="images/userguide/geometrixx-carousel.png"></p>
<div class="trigger-button"><span>Hint: Leveraging the resource type hierarchy</span></div>
<div class="accordion">
    <p><span class="dropcap2">I</span> The resource type given in the @ResourceModel annotation must not be the exact
        resource type of the resource; you may also specify  any resource super type of the resource, primary
        node type or mixin type. In our case, the resource super type of the carousel is &quot;foundation/components/list&quot;
        (see the carousel component in /libs/foundation/components/carousel). Try using this resource type in your
        model, and you will notice that it works, too.  This way, you can provide general models for super types,
        and more specific models for derived types, e.g. a generic model for pages and  a more specific model
        for specific page types.</p>
</div><!--END ACCORDION-->

<p>Create the following class in your bundle package (i.e. within or below the &quot;my.bundle.namespace&quot;
    package)</p>
<p>
{% highlight java %}
@ResourceModel(types = "foundation/components/carousel")
public class Carousel {
}
{% endhighlight %} 
</p>

<p>Build it and install the bundle in the OSGi container. Make sure the bundle is active. Now open the <a
        href="http://localhost:4502/system/console/modelregistry">NEBA model registry</a> tab in the sling console.
    Your model should appear in the model list. If not, check the error.log; something might be wrong with your bundle -
    e.g. it might not be detected by gemini-blueprint.</p>

<div class="trigger-button"><span>Hint: Background information on resource models</span></div>
<div class="accordion">
    <p><span class="dropcap2">I</span> Classes annotated with @ResourceModel are <a
            href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-definition">regular
        spring beans</a>. If you look at the @ResourceModel annotation, you will notice that it is itself annotated
        with @Component (a spring stereotype) and @Scope(PROTOTYPE). <a
                href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-classpath-scanning">With
            these annotations, the class is detected by Spring's classpath scanning</a>. It is entirely possible to
        give your model a different scope (such as singleton) if it represents a &quot;static&quot; piece of
        content, such as configuration content stored under /etc/. Furthermore, all capabilities of the spring
        container are available to the model, such as IOC (dependency injection), e.g. using the <a
                href="http://jcp.org/en/jsr/detail?id=330">JSR-330 @Inject</a> annotation, bean lifecycle
        annotations such as @PostConstruct and @PreDestroy, @Scheduled methods and so forth.</p>
</div><!--END ACCORDION-->

<p>To use this model in a JSP, add the neba:defineObjects tag to the carousel script: <a
        href="http://localhost:4502/crx/de/index.jsp#/crx.default/jcr%3aroot/libs/foundation/components/carousel/carousel.jsp">/libs/foundation/components/carousel/carousel.jsp</a>:
</p>

<h3 id="nebaDefineObjects">The neba:defineObjects tag</h3>

<p>
{% highlight java %}<%@taglib prefix="neba" uri="http://www.neba.io/taglibs/cq/neba/core/1.0"%>
<neba:defineObjects />
{% endhighlight %} 
</p>

<p>neba:defineObjects looks up the most specific model for the current resource and publishes it into the JSP context under the key &quot;m&quot;.  You may now output the model like so:</p>

<p>
{% highlight java %}${m}{% endhighlight %} 
</p>

<p>
    The <em>most specific model</em> is the one that is targeted to the closest resource's type within a resources
    hierarchy. For example, of the resource has the type "cq:Page" and the super type "nt:base", a  model
    for "cq:Page" is <em>more specific</em> than one for "nt:base". If there are more than one most specific models, e.g. two models
    for "cq:Page", the neba:defineObjectsTag will not provide the model automatically. Then, you can explicity specify the desired model's
    bean name (you can lookup the bean name in the <a href="http://localhost:4502/system/console/modelregistry">model registry</a>):
</p>

<p>
{% highlight java %}
<neba:defineObjects useModelNamed="carousel"/>
{% endhighlight %}
</p>

<h3 id="resourceToModelMapping">Mapping properties and resources to models</h3>

<p>
    To make it more interesting, we can now add some of the resource's properties to the model. You can see the
    properties e.g. in the CRXDE light.</p>
<p>
    <img src="images/userguide/geometrixx-carousel.png">
</p><p>Let's take &quot;pages&quot;, &quot;playSpeed&quot;, &quot;transTime&quot; and add them to the model:</p>

<p>
{% highlight java %}
@ResourceModel(types = "foundation/components/carousel")
public class Carousel {
    private String playSpeed;
    private String transTime;
    private List<Resource> pages;

    public String getPlaySpeed() {
        return playSpeed;
    }
    public String getTransTime() {
        return transTime;
    }
    public List<Resource> getPages() {
        return pages;
    }
}
{% endhighlight %} 
</p>

<p>Now build and deploy your bundle again and output the properties in the JSP like so:
<p>
{% highlight java %}Play speed: ${m.playSpeed}<br />
Trans time: ${m.transTime}<br />
Pages: ${m.pages}
{% endhighlight %} 
</p>

<p>You will see the following output:</p>

<p>
{% highlight java %}Play speed: 6000
Trans time: 1000
Pages:
{% endhighlight %} 
</p>

<h3 id="resourceAnnotations">Annotations for advanced resource to model mapping</h3>

<p>NEBA automatically maps the properties of a Resource to fields named like the properties, unless the field is
    annotated with @Unmapped.  Notice that play speed and trans time are Strings in this example, whereas one would
    expect them to be integers. This is simply because these values are defined to be Strings in the component's CQ
    dialog. Had they been defined as integers, we could also retrieve them as integers. You will also notice that &quot;pages&quot;
    is null. And no wonder - the &quot;pages&quot; property is actually of type &quot;String[]&quot;, so the field
    should also be of type String[] and not List&lt;Resource&gt;. However, NEBA offers a simple way to declare that a
    field contains one ore more <em>references</em> to other Resources. Simply add the @Reference annotation like so:</p>

<p>
{% highlight java %}
@Reference
private List<Resource> pages;
{% endhighlight %} 
</p>

<p>Deploy, and load the page again. Now all referenced pages get listed:</p>

<p>
{% highlight java %}Play speed: 6000
Trans time: 1000
Pages: [JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/techsummit, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/userconf, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/shapecon, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/dsc]
{% endhighlight %} 
</p>

<p>When NEBA detects a @Reference annotation, it assumes that the <em>value</em> of the corresponding property
    (here: &quot;pages&quot;) is one or more resource paths. It obtains the corresponding resources and provides them as
    a Collection (or a single resource, if the annotated field is not a collection type). However, you are not limited
    to using &quot;Resource&quot; for your reference. The following also works, provided there is a &quot;Page&quot;
    model the referenced resources can be adapted to:</p>

<p>
{% highlight java %}@Reference
private List<Page> pages;
{% endhighlight %} 
</p>

<p>Here, NEBA loads the resource referenced in the &quot;pages&quot; property, adapts each resource to &quot;Page&quot;
    and returns a collection containing the resulting Page instances.</p><p>While the page hierarchy is conveniently
    navigable using the Page model (i.e. using getChildren()), one often uses the children of a resource (via
    Resource.listChildren()), for instance when loading the contents of a paragraph system. For this, NEBA offers
    another powerful annotation: @Children. This annotation can be used on a Collection, Set or List-typed field
    (similar to the @Reference-annotation). Then, NEBA injects the children of either the current resource (if no other
    annotation is present), or of the resource defined by the @Reference or @Path of the field:</p>


<p>
{% highlight java %}@Children
private List<Resource> children;
{% endhighlight %} 
</p>

<p>Of course, NEBA will also automatically adapt the children to the generic type of the list - for instance,
    you could write:</p>

<p>
{% highlight java %}
@Children
private List<Page> childPages;
{% endhighlight %} 
</p>

<p>@Children can be combined with both @Reference and @Path to even fetch the children of a reference resource
    or a resource designated by a specific path, i.e. the following works as well:</p>

<p>
{% highlight java %}
@Path("/content/site")
@Children
private List<Page> countryPages;

@Reference
@Path("link")
@Children
private List<Page> linkChildren;

@Reference
@Children
private List<Page> link;
{% endhighlight %} 
</p>

<p>Now, lets add another property to the model, jcr:lastModified.</p>

<p>
{% highlight java %}private Date lastModified;{% endhighlight %} 
</p>

<p>This will not yet work - NEBA mapps the properties by <em>name</em>, in this case the name contains
    characters (&quot;jcr:&quot;) unsuitable for a field name.  In this case, use the @Path annotation to specify
    the property from which the field's value shall be obtained:</p>

<p>
{% highlight java %}
@Path("jcr:lastModified")
private Date lastModified;
{% endhighlight %} 
</p>

<p>Now the property is mapped!  @Path has even more interesting features, for instance allowing absolute and
    relative paths.  Try this:</p>

<p>
{% highlight java %}
@Path("/content/geometrixx/en")
private Resource en;
{% endhighlight %} 
</p>

<p>While specifying path is nice, it is often undesirable. Thus, it is possible to use placeholders in the @Path
    mappings to dynamically provide path elements. A better version of above code might be:</p>

<p>
{% highlight java %}
@Path("/content/geometrixx/${language}")
private Resource homepage;
{% endhighlight %} 
</p>

<p>To resolve ${language} placeholder, one simply provides a bean implementing the PlaceholderVariableResolver
    interface. Such a bean instance will be asked  to resolve the value for a placeholder key, i.e. &quot;language&quot;
    in the above example. A completely hardcoded example would be:</p>

<p>
{% highlight java %}
@Service
public class MyVariableResolver implements PlaceholderVariableResolver {
    public String resolve(String variableName) {
        if ("language".equals(variableName)) {
            return en;
        }
        return null;
    }
}
{% endhighlight %} 
</p>

<p>This tutorial uses &quot;Resource&quot; for simplicity's sale. If you specify a different type, NEBA will
    automatically try to adapt  the referenced Resource to the target type. Instead of List&lt;Resource&gt; pages in
    the above example, you could also provide a model for pages and write the following:</p>

<p>
{% highlight java %}
@Reference
private List<Page> pages;
{% endhighlight %} 
</p>

<p>The same applies to members injected with an absolute @Path and the @This annotation; if you have multiple
    models compatible  to your resource, you may also write:</p>

<p>
{% highlight java %}
@This
private OtherModel resource;
{% endhighlight %} 
</p>

<p>You can also use the @This annotation to obtain the Resource that is mapped onto the model:</p>

<p>
{% highlight java %}
@This
private Resource resource;
{% endhighlight %} 
</p>

<div class="trigger-button"><span>Hint: Models for crosscutting concerns</span></div>
<div class="accordion">
    <p><span class="dropcap2">I</span> A @ResourceModel is not restricted to sling:resourceType's - you can also map
        it to the JCR primary node type or any of the mixin types of a Node.  For example, let's assume that you
        have a requirement to implement a custom access protection of <em>arbitrary</em> content. IN addition, an editor may configure
        access restriction to any content (e.g. pages or a DAM assets). In this case we neither know the resource
        types nor the content paths to which the protection applies in advance.
        Here, using a mixin node type could help. A mixin can be assigned to any
        node at any time anywhere in the content hierarchy. It can define additional properties that can be set
        on the node, such as a set of properties defining how an access restriction is configured. Let us
        assume a protected content is assigned the mixin &quot;myProject:AccessRestricted&quot;. You may then create
        a model for any access restricted content like so:</p>

<p>
{% highlight java %}
@ResourceModel(types = "myProject:AccessRestricted")
public class AccessRestricted {
 ....
}
{% endhighlight %} 
</p>
<p>Finally, you could adapt to this model (e.g., in a view or filter) to determine whether the
    corresponding resource has restricted access, and what the restrictions are.</p>

<p>Further reading: <a href="http://www.day.com/specs/jcr/2.0/3_Repository_Model.html">JCR repository
    spec</a>, <a href="http://dev.day.com/docs/en/crx/current/using_crx/nodetype_administration.html">administering
    node types</a>.</p>
</div><!--END ACCORDION-->

<div class="trigger-button"><span>Hint: How NEBA uses resource types in Sling</span></div>
<div class="accordion">
    <p><span class="dropcap2">I</span> The <a href="http://sling.apache.org/site/index.html">Sling webframework</a> is a REST architecture implementation.
        Consequently, it treats each thing
        it works with (every piece of content, every script, servlet) as a <a href="http://sling.apache.org/site/resources.html">Resource</a>.
        Resources are strongly typed by their attribute <em>sling:resourceType</em>.
        Thus, every component we are writing and every piece of content (i.e. concrete component instance created by an editor by
        placing a component on a site) has a resource type. Resource types - very much like types in many other languages - also support inheritance
        by means of a <em>sling:resourceSuperType</em> attribute.</p>

    <p>Resource types are used by Sling to determine the view(s) that shall be used to render the resource. It does so by adding
        a prefix such as /apps or /libs to the resource type and checking whether it finds views for the
        resource in the corresponding directory.</p>

    <p>Furthermore, any content stored in the JCR is represented by a javax.jcr.Node - this node also has a <em>primaryType</em>
        as well as one or more <em>mixin types</em> and <em>super types</em>.</p>

    <p>In order to provide a JAVA model for a resource, it thus makes sense to either associate
        it with the resource's sling:resourceType or the resource's JCR type. This association is represented using a @ResourceModel
        annotation.</p></div><!--END ACCORDION-->

<h3 id="modelInitialization">Performing additional initializations</h3>

<p>It is often required to perform some additional initializations
    after all properties of a @ResourceModel are mapped. NEBA supports this use case with the @PostMapping and
    @PreMapping annotations.  Similar to @PostConstruct and @PreDestroy from standard Java, these annotations mark methods to be
    invoked after all properties of a resource model are mapped from its resource:</p>


<p>
{% highlight java %}@ResourceModel(types = "my/model/type")
public class MyModel {
   @This
   private Resource resource;
   @PostMapping
   public void initializeSomething() {
        // resource is initialized at this point.
        this.resource.adaptTo...
   }
}
{% endhighlight %} 
</p>

<p>Likewise, @PreMapping allows for method execution before any properties of the resource are mapped.</p>

</div>

<div class="divider-border"></div>

<div class="one">
<h2 id="beanscopes">Support for web-specific bean scopes</h2>
<p>Beans in Spring have scopes. By default, beans are application scoped
    (i.e. singletons). @ResourceModels have prototypical scope, i.e. they are re-created every time they are obtained from
    the bean factory. In a web context, objects may also be scoped to the current request or the current session.<br/>
    NEBA provides support for the request scope, i.e. a bean may be defined like so:</p>

<p>
{% highlight java %}
@Component
@Scope(WebApplicationContext.SCOPE_REQUEST)
public class MyType {
  ...
}
{% endhighlight %} 
</p>

<p>However, the session scope is currently not supported since it leads to a lot of issues (lack of scalability
    due to the need of session stickiness to an instance, high memory usage, serialisation etc.) In a RESTful
    Application, the session should not be used. User data may instead be stored in a cookie; if server-side state
    inevitable, storing it in a shared data store (e.g. a shared JCR repository or relational DB) and retrieving it upon
    request is a much more scalable, cleaner solution.</p>

</div>

<div class="divider-border"></div>

<div class="one">
<h2 id="usingvelocity">Rendering beyond resources with velocity</h2>

<p>While JSP provides solid templating for Sling, it's not that great at rendering objects that are not resources. Custom models, e.g.
    database entities or build-in types such as java.util.Date are quite often rendered repeatedly in different templates.
    Also, you may want to render different variants of the same resource or object but may not be able to make use of selectors, suffixes or
    extensions in the URL. Finally, rendering resources outside of a request - for instance in a scheduled task - may be desirable.
    NEBA provides a simple solution: Any object can be rendered with velocity.</p>

<h3>Configuring Velocity rendering</h3>

<p><a href="http://velocity.apache.org/engine/devel/user-guide.html">Velocity</a> uses .vlt
    templates. NEBA stores these templates in the JCR. Where exactly the templates are located is configurable via the
    <a href="http://localhost:4502/system/console/configMgr">sling console</a>. Look up the configuration &quot;Sling
    spring Bean Renderer configuration&quot;. Each line of the configuration binds a path in the repository to an
    arbitrary name. The combination of name and path is used by NEBA to provide a BeanRenderer instance via the
    BeanRendererFactory OSGi Service under the given name. This makes it possible to define multiple view repositories
    (e.g. for rendering the same type of object in different ways for different sites).</p><p>By default, i.e. if no
    renderer is explicitly specified, the renderer named &quot;default&quot; is used. If not yet configured, add the
    following line to the configuration:</p>


<p>
{% highlight java %}default:/apps/neba/views/{% endhighlight %}
</p>

<h3>Using Velocity templates with the NEBA taglib in JSP</h3><p>Let's continue by editing carousel JSP template
    (/libs/foundation/components/carousel/carousel.jsp). Replace the ${m.lastModified} with the following JSP tag:</p>

<p>
{% highlight xml %}<neba:render object="${m.lastModified}" />{% endhighlight %}
</p>

<p>If you have no model for the current resource, you may also simply use the properties object (a Map) provided
    by sling, like so:</p>


<p>
{% highlight xml %}<neba:render object="${properties['jcr:lastModified'].time}" />{% endhighlight %}
</p>

<p>Reload - you will see no output. Let's create a template. Open <a
        href="http://localhost:4502/crx/de/">CRXDE</a> and create the folder /apps/neba/views.  In this folder,
    create the folder /java/lang/. In there, create a file named &quot;Object.vlt&quot; like so:</p>

<p>
{% highlight java %}Hello, I am: $m{% endhighlight %} 
</p>

<p>Reload. You will see something like &quot;Hello, I am: Tue Dec 05 14:14:27 CEST 2011&quot;. How did this
    happen? NEBA uses the type hierarchy of every object it renders to derive a template name. If no template exists for
    a object's type, it will look for a template for the interfaces the object implements; if no template exists for any
    of the interfaces, it will use the supertype and its interfaces and so on. This way, you can use the type hierarchy
    to define default views for types and provide specialized views for derived types.  NEBA stores the templates in
    a hierarchy matching the object types package name to avoid name collisions. for a type called my.package.Foo, the
    template is thus &lt;renderer root path&gt;/my/package/Foo.vlt. Try it: create the folder /java/util/ in
    /apps/neba/views/ and place a template called Date.vlt in it:</p>

<p>
{% highlight java %}I am the date: $m{% endhighlight %} 
</p>

<p>Reload - NEBA will now use you Date.vlt template. Sweet - now no matter where you output a date you can
    always use the render tag and thus re-use the same template. This mechanism can be used for any JAVA object!<br/>
    You can also create variants of the same view. A java.util.Date, for instance, may be rendered in different ways
    with regard to the current locale.  For this, the render tag allows the specification of a <em>viewHint</em>.
    Create the following a templated called "Date-US.vlt" in the java/util folder:</p>

<p>
{% highlight java %}I am a US date: $m{% endhighlight %} 
</p>

<p>You can now use this view like so:</p>

<p>
{% highlight xml %}<neba:render object="${m.lastModified}" viewHint="US" />{% endhighlight %}
</p>

<div class="trigger-button"><span>Hint: Configuring the velocity rendering</span></div>
<div class="accordion">
    <p><span class="dropcap2">I</span> The velocity engine is configured to cache a template for 60 seconds; this is
    configurable in the sling console (Unic sling spring bean renderer configuration).  You can also specify
    &quot;fallback&quot; templates with view variants, e.g. the fallback for Date-CH.vlt would be Object-CH.vlt
    (not Object.vlt).  If you configure multiple bean renderers, you can target the in the render tag by
    providing their name via the &quot;renderer&quot; property.</p></div><!--END ACCORDION-->

<p>Rendering an object must not stop in the current template. The current BeanRenderer is always available in
    your template under the name &quot;renderer&quot; (see Constants class in the API).  This is great when
    rendering objects that are composed of several other objects. You may, for example, render our Carousel model like
    so:</p>

<p>
{% highlight xml %}<neba:render object="${m}" />{% endhighlight %}
</p>
<p>With a velocity template like so:</p>
<p>
{% highlight xml %}
I am a Carousel. I was last modified at $renderer.render($m.lastModified)<br />
I contain the following pages:<br />
<ul>
#foreach( $page in $m.pages )
    $renderer.render($page, "listitem")
#end
</ul>
{% endhighlight %} 
</p>

<p>Thus, each page resource would be rendered using the template "Resource-listitem.vlt":</p>

<p>
{% highlight xml %}<li>$m.path</li>{% endhighlight %}
</p>

<p>This yields optimal re-use of views per type.</p><p>You may also want to add additional utilities to the
    rendering context to access using ${somekey}, such as a tool for message formatting and the like. For this, NEBA
    supports the <a href="https://cwiki.apache.org/confluence/display/SLING/Scripting+variables">Sling scripting
        variables configuration</a>. However, adding variables by supplying a HashMap service interface is not supported
    (this is considered bad practice), i.e. to add scripting context variables, export a Service of the type
    BindingsValuesProvider. The &quot;javax.script.name&quot; service property must either be &quot;all&quot; or &quot;velocity&quot;.
</p><h3>Providing additional context to velocity scripts</h3><p>Besides the <em>BindingsValuesProvider</em>, you can
    also add additional key/value pairs to the context of a specific &lt;neba:render ... /&gt; call by adding arbitrary
    attributes to the tag, like so:</p>
<p>
{% highlight xml %}<neba:render object="${m}" cssClasses="class1 class2" highlight="${highlight}" />{% endhighlight %}
</p>

<p>This will lead to the variables &quot;${cssClasses}&quot; and &quot;${highlight}&quot; to become available in
    the velocity script of the corresponding rendering process.</p>
</div>

<div class="divider-border"></div>

<div class="one">
<h2 id="springmvc">Using Spring MVC in Sling</h2>

<p>By default, Sling supports two kinds of scripts: JSPs to render arbitrary JCR resources and <a href="http://sling.apache.org/site/servlets.html">Servlets</a>.
    While the former is a decent way to render dynamic resources, i.e. content pages and components that have no fixed
    URL, the latter is usually used to provide RESTful services with a fixed URL.  However, Servlets are very
    primitive. They do not provide separation of controller, model and view or commoon yet complicated features such as
    form data binding. Thus, NEBA completely supports Spring MVC (except for themes support, which relies on a style of
    resource loading incompatible with OSGi) to enable clean, simple and RESTful MVC with fixed URLs.</p>

<p>To avoid conflict with resource resolution and servlet mappings, <a
        href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/mvc.html">Spring MVC</a>
    is integrated into Sling using a Servlet with the fixed URL &quot;/bin/mvc&quot; (you may use servlet resolver
    mapping to change this path). Since each distinct path in sling mapps to a different resource (Servlets are
    resources, too), the path /bin/mvc/url would not point to the /bin/mvc/ servlet. Thus, to have a request handled by
    the MVC servlet, the pseudo-extension&quot;.do&quot; is used. A spring controller with the URL /my/controller/path
    is thus always addressed using /bin/mvc.do/my/controller/path. One may also use an extension and selectors (e.g.
    /bin/mvc.do/my/controller/path.selector1.selector2.xml). </p><p>Let's create a simple Controller called &quot;DemoController&quot;.
    We will use Spring's @Controller annotation; other styles (such as mapping by bean names etc.) are also
    supported.  The purpose of this controller is to echo a parameter that we provide in a RESTful way, i.e. as a
    path element (this allows caching!).</p>

<p>
{% highlight java %}
@Controller
public class DemoController {
}
{% endhighlight %} 
</p>

<p>A @Controller is also automatically detected and registered (as a singleton) by Spring's classpath scanning.
    Now we will use Spring's REST support to both define the URL the controller listens to and the parameter we expect:</p>

<p>
{% highlight java %}
@Controller
public class DemoController {
    @RequestMapping("/echo/{param}")
    @ResponseBody
    public String echo(@PathVariable("param") String paramToEcho) {
       return paramToEcho;
    }
}
{% endhighlight %} 
</p>

<p>That's it. You may now call your controller e.g. with /bin/mvc.do/echo/HelloWorld.txt.</p><p>In addition,
    NEBA supports the common use case of handling resource paths in controllers with a convenience annotation:</p>

<p>
{% highlight java %}
@Controller
public class DemoController {
    @RequestMapping("/echoTitle")
    @ResponseBody
    public String echo(@ResourceParam Page page) {
       return page.getTitle();
    }
}
{% endhighlight %} 
</p>

<p>Here, a request parameter &quot;page&quot; is expected and treated as a path to a resource. This resource is
    resolved, and is adapted to the parameter type in case the parameter type is not &quot;Resource&quot;. See the
    ResourceParam annotation for details.</p><p>Note that the annotation-driven controllers have a lot more very powerful options. See the <a
        href="http://docs.spring.io/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/mvc.html">Spring MVC
    documentation</a> for more examples. NEBA also supports Spring&apos;s special view names for redirecting and
    forwarding views: returning &quot;redirect:/some/path&quot; from a controller method will cause a redirect to
    /some/path, returning forward:/some/path will forward the request to /some/path, see also
    <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/mvc.html#mvc-redirecting">MVC
    redirecting</a>.</p><p>You may also directly work with the response. For this, provide your own
    org.springframework.web.servlet.View in the org.springframework.web.servlet.ModelAndView provided by the controller;
    this way, your View's render method is used to render the response. Alternatively, you may also simply write to the
    response and either let the controller method return &quot;null&quot; or make it void. This is however bad practice
    and thus discouraged.</p><h3>Configuring MVC logging</h3><p>Internal errors during controller invocation, e.g. when
    required parameters are missing, are logged to the logs/error.log on &quot;warn&quot; level by default. It is highly
    recommended to configure a separate logfile for these messages and disable this logging on production, since it is
    very likely for such exceptions to arise constantly due to user mistakes, bot activity and the like. To configure a
    custom logile, simply create a new Apache Sling Logging Logger Configuration using &quot;mvc&quot; as the Logger
    name, like so:</p>

<img src="images/userguide/mvc-logger-configuration.png" />
</div>

<div class="divider-border"></div>

<div class="one">
<h2 id="extending">Extending NEBA</h2>

<h3>Customizing the Spring MVC infrastructure</h3>
<p>You may provide implementations of
    <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/javadoc-api/org/springframework/web/servlet/HandlerAdapter.html">Handler adapters</a>,
    <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/javadoc-api/org/springframework/web/servlet/HandlerExceptionResolver.html">Handler exception resolvers</a>
    and <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/javadoc-api/org/springframework/web/servlet/HandlerMapping.html">Handler mappings</a>
    in your application context and / or use Spring's &lt;mvc&gt; XML namespace configuration without
    limitations.</p><p>Lifecycle callbacks</p><p>Additional functionality is usually provided by simply adjusting the
    spring context configuration to the project needs (i.e. configuring <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html">beans</a>
    and customizing the bean <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-factory-lifecycle">lifecycle</a>).
</p>

<p>However, there is an additional lifecycle phase of @ResourceModels in beans: after creation, dependency injection
    and initialization, a resource model is injected with the properties of the resource which is adapted to the model.
    For programmatic extensibility, the NEBA API contains the lifecycle callback interface <em>ResourceModelPostProcessor</em>.<br/>
    Providing an OSGi service with this interface allows customization and even overriding of a ResourceModel before and
    / or after the resource properties are mapped on it.  The demo project's com.unic.cq.foundation.demo.i18n
    package and context.xml contain an example of how this lifecycle callback can be used to support an additional
    annotation on a resource model.</p><h3>Extending the tag library</h3><p>NEBA's <em>DefineObjectsTag</em> and <em>RenderTag</em>
    are not extensible as they are part of the NEBA core to which a project must not have direct dependencies.Thus,
    writing a standalone tag library is the correct approach to avoid tight coupling to implementation details of the
    NEBA tag library.</p>

<h3>Caching and cache extension</h3>
<p>
NEBA's central and most performance critical feature is the adaptation of Resources to their corresponding resource models.
There, resource and model resolution, content-to-object mapping and datatype conversion occurs.
This core functionality features an extensible caching
interface. Any OSGi service implementing the NEBA API interface <em>ResourceModelCache</em> will automatically be
registered and used to cache the result of the resource to model adaptation.</p><p>NEBA ships with a safe and
sensible default implementation of this interface contained in the core, the <em>request-scoped resource model
cache.</em>
This cache can be enabled or disabled via the Felix console (configuration tab). If you would like
to provide your own caching implementation, consult the Javadoc of the <em>ResourceModelCache</em> <em>for further
information.</em></p>
</div>